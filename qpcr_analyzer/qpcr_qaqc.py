"""
qpcr_qaqc.py
============

Perform QA/QC on QPCR data generated by qpcr_populator.py.

More instructions and comments coming soon.
"""

import pandas as pd
from openpyxl.utils import get_column_letter
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.styles import PatternFill
from qpcr_utils import load_config
from functools import partial
import numpy as np
import re
from openpyxl.styles.differential import DifferentialStyle
from openpyxl.formatting.rule import Rule
from openpyxl.styles import Font

from qpcr_utils import (
    MAIN_SHEET, 
    MAIN_COL_BL_CT, 
    MAIN_COL_CT_AVG, 
    OUTLIER_COL,
    MAIN_ROW_DATA,
    CAL_ROW_DATA,
    CAL_SHEET_FMT,
    add_sheet_name_to_colrow_name,
    flatten,
    parse_colrow_tags,
)

QAQC_SHEETNAME = "QAQC-{}"

CATEGORY_COL = "Category"
DESC_COL = "Description"
PRIORITY_COL = "Priority"
GROUP_COL = "Group"
SAMPLE_ID_COL = "Sample ID"
GENES_COL = "Genes"
CELL_A_COL = "Cell A"
CELL_B_COL = "Cell B"
LOWER_LIMIT_COL = "Lower Limit"
UPPER_LIMIT_COL = "Upper Limit"
VALUE_COL = "Value"
VALIDATES_COL = "Validates"
NOTES_COL = "Notes"

DEFAULT_QAQC_DATA = {
    CATEGORY_COL : "",
    DESC_COL : "",
    PRIORITY_COL : "",
    GROUP_COL : "",
    SAMPLE_ID_COL : "",
    GENES_COL : "",
    CELL_A_COL : None,
    CELL_B_COL : None,
    LOWER_LIMIT_COL : None,
    UPPER_LIMIT_COL : None,
    VALUE_COL : None,
    VALIDATES_COL : None,
    NOTES_COL : None,
}

QAQC_DEFAULT_VALIDATES_FORMULA = "OR(AND(LEFT({col='Value'}{row}, 1)=\"[\", RIGHT({col='Value'}{row}, 1)=\"]\"), AND(ISNUMBER({col='Value'}{row}), OR({col='Value'}{row}>={col='Lower Limit'}{row}, {col='Lower Limit'}{row}=\"\"), OR({col='Value'}{row}<={col='Upper Limit'}{row}, {col='Upper Limit'}{row}=\"\")))"
QAQC_DEFAULT_ISERROR = "OR(ISERROR({col='Value'}{row}), ISERROR({col='Lower Limit'}{row}), ISERROR({col='Upper Limit'}{row}))"
QAQC_ACCEPT_BLANK_FORMULA = "{col='Value'}{row}=\"\""
QAQC_VALUE_FORMULA = "={cell_ref}"

QAQC_HAS_FAILED_CATEGORY_FORMULA="IF(COUNTIF('{qaqc_sheet}'!{cat_column}:{cat_column},\"{category}\")=0,\"{empty}\", IF(COUNTIFS('{qaqc_sheet}'!{cat_column}:{cat_column},\"{category}\",'{qaqc_sheet}'!{validates_column}:{validates_column},FALSE)>0,\"{failed}\", \"{success}\"))"

# If a QAQC sheet with the same name already exists the delete it if this is True. If we do delete it
# then the conditional formatting in the main sheet, for an older run, might be incorrect, since it will
# refer to the new QAQC sheet (it will only be correct if the new QAQC sheet is identical to the old one).
DELETE_EXISTING_SHEET = True

class QPCRQAQC(object):
    def __init__(self, populator, qaqc_config_file, config_file):
        super().__init__()
        self.populator = populator
        self.qaqc_config = load_config(qaqc_config_file)
        self.config = load_config(config_file)
        self.current_name = None
        self.formatting_rules = {}
        if self.has_qaqc():
            self.prepare_styles()

    def get_qaqc_column_index(self, column):
        if column not in DEFAULT_QAQC_DATA.keys():
            return None
        return list(DEFAULT_QAQC_DATA.keys()).index(column)

    def set_current_name(self, name):
        self.current_name = name

    def get_sheet_name(self, name=None):
        return QAQC_SHEETNAME.format(self.current_name if name is None else name)

    def has_qaqc(self):
        return self.qaqc_config is not None

    def get_next_qaqc_row(self):
        """Get the next empty row number in the QA/QC sheet. The row number is the Excel row number
        (ie. first row (1) is header, then the data rows start at row 2)
        """
        return len(self.qaqc_df.index) + 2        

    def init_qaqc(self, wb, group):
        """Initialize the QAQC Worksheet for the specified group name. The group is usually an analysis date.
        """
        self.qaqc_df = None
        # self.formatting_rules = {}

        if self.qaqc_df is None:
            self.qaqc_df = pd.DataFrame(columns=DEFAULT_QAQC_DATA.keys())

    def run_qaqc(self, output_wb, df, full_df, name=None):
        """Run a full QAQC on the final generated output sheets. Uses both the
        populated Excel sheets currently in memory and the original df used to generate it.

        Parameters
        ----------
        df : pd.DataFrame
            The DataFrame used to generate the worksheets that are currently in memory, for the current subgroup of the full df.
        full_df : pd.DataFrame
            The full DataFrame containing all input, not just the ones from the current df. This might be used for some
            QAQC that requires checking an entire plate (eg. checking that NTCs are above the maximum Ct for an entire plate)
        output_wb: openpyxl.Workbook
            The Workbook we are performing QAQC on. This is where the QAQC results will be stored.
        name : str
            A descriptive name. Used for some informative output and for naming the QAQC sheet. If None
            then the value last passed to set_current_name is used. The final name used will be based on this
            value.
        """
        if not self.has_qaqc():
            return
        # if not self.main_has_data():
        #     return

        if name is not None:
            self.set_current_name(name)

        self.output_wb = output_wb
        self.init_qaqc(self.output_wb, self.current_name)

        main_ws, main_info = self.populator.get_worksheet_and_info(MAIN_SHEET)

        # NOTE: qaqc_run_check_ct_stdev doesn't need to be run. Actual removal of outliers is
        # done in remove_all_outliers, and highlighting of the error cells is done independently of
        # qaqc_run_check_ct_stdev in add_qaqc_to_workbook. Running qaqc_run_check_ct_stdev will
        # highlight ALL Ct values if the standard deviation is too large
        # self.qaqc_run_check_ct_stdev(self.current_name)
        self.qaqc_run_ntc(self.current_name, df, full_df)
        self.qaqc_run_sample_data_available(self.current_name)
        # self.qaqc_run_no_detections(self.current_name)
        self.qaqc_run_standard_curves(self.current_name)
        self.qaqc_run_standard_curve_inter_comparisons(self.current_name)
        self.qaqc_run_samples_within_standard_curves(self.current_name)
        self.qaqc_run_loq(self.current_name)
        self.qaqc_run_baseline_in_range(self.current_name)
        self.qaqc_run_inhibition(self.current_name)
        self.qaqc_run_comparable_genes(self.current_name)
        self.qaqc_run_copies_outliers(self.current_name)
        self.qaqc_run_non_detects(self.current_name)

    def excel_range_check_formula(self, rng, value_refs, combine_func):
        """Create an Excel formula to check if values are within the specified range (without the leading '=').

        Parameters
        ----------
        rng : list (2 elements)
            rng[0] is the lower limit of the range (if None then no lower limit), rng[1] is the upper
            limit (if None then no upper limit). The lower limit is exclusive, upper limit is inclusive.
        value_refs : str | list | tuple | np.ndarray
            Array of values to check. Can be numbers, cell addresses, other Excel formulas, etc. Each item
            is checked to see if it is in the range.
        combine_func : str
            The function used to combine all the check for each value in value_refs. Can be "OR" (to test if at least
            one value is in range) or "AND" (to test if all values are in range).
        
        Returns
        -------
        str
            The Excel formula (without the leading '='). eg. OR(AND(A1>1,A1<=3), AND(A2>1,A2<=3))
        """
        if isinstance(value_refs, str):
            value_refs = [value_refs]
        formulas = []
        # Each value_refs must be tested
        for value_ref in value_refs:
            lt = f"{value_ref}<={rng[1]}"
            gt = f"{value_ref}>{rng[0]}"
            if rng[0] is None and rng[1] is None:
                cur_formula = "TRUE"
            elif rng[0] is None:
                cur_formula = lt
            elif rng[1] is None:
                cur_formula = gt
            else:
                cur_formula = f"{combine_func}({lt},{gt})"
            formulas.append(cur_formula)
        if len(formulas) == 0:
            return ""
        elif len(formulas) == 1:
            return formulas[0]
        return "{}({})".format(combine_func, ",".join(formulas))

    def get_validates_formula(self, accept_blanks=False, row_num=None, fail_if_errors=True, override_formula=None):
        """Get the validation Excel formula for the specified row number (with the leading '='). Will
        use the default formula if no formula is specified. The default will check if the QAQC value in 
        the VALUE_COL column is within the range specified in the "Lower" and "Upper" limits. It will also
        use the next available row in the QAQC sheet as the row_num, if none is provided (ie. the row
        that a new formula will be added to the sheet).

        Parameters
        ----------
        accept_blanks : bool
            If True then the validation formula will treat blank values as properly validated. If False then
            blank values are invalid. Excel errors (eg. #DIV/0!) are always treated as invalid.
        row_num : int
            The row number (in the QAQC Excel Worksheet) that the validation formula will be placed on.
        fail_if_errors : bool
            If True then the validation fails if the lower limit, upper limit, or value are errors in the
            QAQC spreadhsheet. If False then the validation succeeds.
        override_formula : str
            If not None, then the formula to use. It is parsed by calling parse_colrow_tags and will accept
            tags for row_num (the row the formula will be in the QAQC sheet), and other tags such as
            {col='Column Name'}, etc. It will also be combined with accept_blanks to allow validation of
            blank values to pass.

        Returns
        -------
        str
            The Excel formula that validates a value in a QAQC sheet (checks that the value in the VALUE_COL
            column is in the range specified in the LOWER_LIMIT_COL and UPPER_LIMIT_COL columns).
        """
        if row_num is None:
            row_num = self.get_next_qaqc_row()
        formula = override_formula or QAQC_DEFAULT_VALIDATES_FORMULA
        if accept_blanks:
            formula = f"OR({formula}, {QAQC_ACCEPT_BLANK_FORMULA})"
        errors_result = "FALSE" if fail_if_errors else "TRUE"
        formula = f"IF({QAQC_DEFAULT_ISERROR}, {errors_result}, {formula})"
        return "={}".format(parse_colrow_tags(formula, self.qaqc_df, row_num))

    def qaqc_run_per_sample(self, name, match_genes, sheet_name, match_col_name, match_row_name, rng, populate_data_func, accept_blanks=False, fail_if_errors=True, mode="flatten"):
        """Go through the specified generated spreadsheet and call a callback (with data) for each row. The
        callback should fill in a QAQC dictionary object with all fields set (see DEFAULT_QAQC_DATA dictionary for 
        the different fields)

        Parameters
        ----------
        name : str
            A descriptive name of the run. Typically used as the QAQC category name.
        match_genes : str | list | tuple | np.ndarray
            Find all rows that match these genes. The gene of the row is the main gene of the row. eg. If the row also contains
            info for a normalization gene (eg. nPMMoV) then the normalization gene is not matched. If match_genes is empty then all
            genes are matched.
        sheet_name : str
            The sheet name to iterate over. eg. MAIN_SHEET.
        match_col_name : str
            When calling the callback, provide the Excel column Ids for all columns matching match_col_name. When multiple columns are
            provided or matched then the behavior depends on the mode parameter eg. We might call the callback once with an
            array of all matched columns, or multiple times with one matched column at a time. Each time the callback is
            called a new QAQC data row might be added.
        @TODO: FINISH COMMENTS
        """
        if isinstance(match_col_name, str):
            match_col_name = [match_col_name]
        if isinstance(match_row_name, str):
            match_row_name = [match_row_name]
        if isinstance(match_genes, str):
            match_genes = [match_genes]
        
        ws, info = self.populator.get_worksheet_and_info(sheet_name)
        if match_genes is not None:
            match_genes = [g.strip().lower() for g in match_genes]

        qaqc_data = DEFAULT_QAQC_DATA.copy()

        # _, info = self.populator.get_worksheet_and_info(sheet_name)
        target_column = [add_sheet_name_to_colrow_name(sheet_name, m) for m in match_col_name]
        target_row = [add_sheet_name_to_colrow_name(sheet_name, m) for m in match_row_name]
        origin = info["origin"]
        for num, (row_data, row_names) in enumerate(zip(info["row_data"], info["row_names"])):
            cur_row = num + origin[0]
            if len(set(target_row).intersection(set(row_names))) > 0 and len(row_data) > 0:
                data = row_data[0]
                row_gene = data[self.config.input.gene_type_col].iloc[0]
                row_sample_id = data[self.config.input.sample_id_col].iloc[0]
                if match_genes is None or len(match_genes) == 0 or (row_gene is not None and row_gene.lower() in match_genes):
                    cols = self.populator.get_named_columns(sheet_name, target_column)
                    if mode == "flatten":
                        # Flatten, then call callback once per item in the flattened array
                        cols = flatten(cols)
                    elif mode == "one_per_match":
                        # Call callback with a single value for each match, ie. call for [cola[0], colb[0], ... coln[0]], then
                        # [cola[1], colb[1], ..., coln[1]], ...
                        cols = np.transpose(cols).tolist()
                    elif mode == "all_at_once":
                        # Flatten, then call callback once with the entire flattened array
                        cols = [flatten(cols)]
                    elif mode == "separate_groups":
                        pass
                    else:
                        raise ValueError(f"Unrecognized mode in qaqc_run_per_sample: {mode}")
                    for cur_col in cols:
                        if isinstance(cur_col, (list, tuple, np.ndarray)):
                            if len(cur_col) == 0:
                                continue
                            cell_ref = None
                            cell_refs = [f"'{ws.title}'!{c}{cur_row}" for c in cur_col]
                        else:
                            cell_ref = f"'{ws.title}'!{cur_col}{cur_row}"
                            cell_refs = [cell_ref]
                        qaqc_data[GROUP_COL] = name
                        # qaqc_data[DESC_COL] = f"{row_gene} LOQ (per well)"
                        qaqc_data[LOWER_LIMIT_COL] = rng[0] if rng is not None else None
                        qaqc_data[UPPER_LIMIT_COL] = rng[1] if rng is not None else None
                        # qaqc_data[VALUE_COL] = f"=IF(ISNUMBER({cell_ref}), {cell_ref}, \"\")" if cell_ref is not None else None
                        qaqc_data[VALUE_COL] = QAQC_VALUE_FORMULA.format(cell_ref=cell_ref)
                        qaqc_data[SAMPLE_ID_COL] = row_sample_id
                        qaqc_data[GENES_COL] = self.get_qaqc_gene_for_column(cur_col, sheet_name, row_gene) # row_gene
                        qaqc_data[CELL_A_COL] = self.make_cell_link(cell_refs, 1)
                        qaqc_data[CELL_B_COL] = self.make_cell_link(cell_refs, 2)
                        qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=accept_blanks, fail_if_errors=fail_if_errors)
                        if populate_data_func(sheet_name, qaqc_data, data, name, rng, cur_row, cur_col):
                            self.qaqc_df = self.qaqc_df.append(qaqc_data, ignore_index=True)

    def qaqc_run_ntc(self, name, df, full_df):
        if "ntcs" not in self.qaqc_config:
            print("WARNING: 'ntc' does not exist in QAQC config file")
            return

        match_row_name = add_sheet_name_to_colrow_name(MAIN_SHEET, MAIN_ROW_DATA)

        for ntc_info in self.qaqc_config.ntcs:
            unit_other = ntc_info.unit_other
            if isinstance(unit_other, str):
                unit_other = [unit_other]

            plates = df[self.config.input.plate_id_col].unique()
            
            ntc_samples = full_df[full_df[self.config.input.unit_other_col].isin(unit_other) & full_df[self.config.input.plate_id_col].isin(plates)]
            genes = [g.strip() for g in ntc_info.genes]
            if len(genes) == 0:
                genes = ntc_samples[self.config.input.gene_type_col].unique()
            ct_range = ntc_info.ct_range

            # Do each gene separately
            for gene in genes:
                # Go through all NTCs
                for idx, ntc_sample in ntc_samples.iterrows():
                    ntc_gene = (ntc_sample[self.config.input.gene_type_col] or "").strip()
                    plate_id = (ntc_sample[self.config.input.plate_id_col] or "").strip()
                    standard_curve_id = (ntc_sample[self.config.input.standard_curve_id_col] or "")#.strip()
                    lower_ntc_gene = ntc_gene.lower()
                    ntc_sample_id = (ntc_sample[self.config.input.sample_id_col] or "").strip().lower()
                    all_cells = []

                    # See if we should handle the current NTC gene
                    if gene is not None and lower_ntc_gene == gene.lower():
                        # if ntc_info.source_max != "cal_gene_ct" and lower_ntc_gene == self.config.input.baseline_id.strip().lower() and self.config.template.hide_baseline_gene_from_main:
                        # We're hiding the baseline gene from the main output, so we need to calculate the minimum Ct from the df
                        if ntc_info.source_max == "all_gene_ct":
                            calc_df = full_df[(full_df[self.config.input.unit_col] == "Ct") & (full_df[self.config.input.gene_type_col].str.lower() == lower_ntc_gene) & (full_df[self.config.input.plate_id_col].str.lower() == plate_id.lower())]
                            max_formula = max(calc_df[self.config.input.value_col].max(), calc_df[OUTLIER_COL].max())
                            # calc_df = df[(df[self.config.input.unit_col] == "Ct") & (df[self.config.input.gene_type_col].str.lower() == lower_ntc_gene) & (df[self.config.input.qa_col].isin(["FALSE", False]))]
                            # max_formula = calc_df[self.config.input.value_col].max()
                        elif ntc_info.source_max == "cal_gene_ct":
                            # Get a literal value
                            cal_sheet_name = CAL_SHEET_FMT.format(gene=gene, plateID=standard_curve_id)
                            max_formula = self.populator.get_calibration_value(cal_sheet_name, "max_ct")


                            #     # Get a cell reference value
                            #     first_std, last_std = self.get_first_and_last_average_standard_cells(gene, plate_id)
                            #     if first_std and last_std:
                            #         max_formula = f"MAX({first_std}:{last_std})"
                            #     else:
                            #         max_formula = None
                        else:
                            raise ValueError(f"Unrecognized source_max for NTC config, must be \"all_gene_ct\" or \"cal_gene_ct\", found \"{ntc_info.source_max}\"")
                        # else:
                        #     if ntc_info.source_max == "all_gene_ct":
                        #         _, ws_info = self.populator.get_worksheet_and_info(MAIN_SHEET)

                        #         # Find all rows in the worksheet that has data and is a matching gene
                        #         for row_num, (row_names, row_data) in enumerate(zip(ws_info["row_names"], ws_info["row_data"])):
                        #             if match_row_name in row_names:
                        #                 cur_genes = [d[self.config.input.gene_type_col].iloc[0].strip().lower() for d in row_data]
                        #                 if lower_ntc_gene in cur_genes:
                        #                     cur_row = row_num + ws_info["origin"][0]
                        #                     if lower_ntc_gene == self.config.input.baseline_id.strip().lower():
                        #                         # use_columns = bl_sample_columns
                        #                         values_range = self.populator.get_named_cells(MAIN_SHEET, None, MAIN_COL_BL_CT, override_row=cur_row, include_sheet_name=True, match_data={"plateID":plate_id})
                        #                     else:
                        #                         values_range = self.populator.get_named_cells(MAIN_SHEET, None, MAIN_COL_CT, override_row=cur_row, include_sheet_name=True, match_data={"plateID":plate_id})
                                            
                        #                     all_cells.extend(values_range)
                        #         if len(all_cells) == 0:
                        #             max_formula = None
                        #         else:
                        #             max_formula = "MAX({})".format(",".join(all_cells))
                        #     elif ntc_info.source_max == "cal_gene_ct":
                        #         first_std, last_std = self.get_first_and_last_average_standard_cells(gene, plate_id)
                        #         max_formula = last_std
                        #     else:
                        #         raise ValueError(f"Unrecognized source_max for NTC config, must be \"all_gene_ct\" or \"max_gene_cal_ct\", found \"{ntc_info.source_max}\"")

                        lower = f"{max_formula}+{ntc_info.delta_from_max_ct}" if not pd.isna(max_formula) else None
                        if ntc_info.ct_range[0] is not None and lower is not None:
                            lower = f"MIN({lower}, {ntc_info.ct_range[0]})"
                        upper = ntc_info.ct_range[1]

                        qaqc_data = DEFAULT_QAQC_DATA.copy()
                        qaqc_data[GROUP_COL] = name
                        qaqc_data[CATEGORY_COL] = ntc_info.category.format(gene=ntc_gene)
                        qaqc_data[DESC_COL] = ntc_info.description.format(gene=ntc_gene)
                        qaqc_data[PRIORITY_COL] = ntc_info.priority
                        qaqc_data[LOWER_LIMIT_COL] = f"={lower}" if lower is not None else None
                        qaqc_data[UPPER_LIMIT_COL] = f"={upper}" if upper is not None else None
                        qaqc_data[VALUE_COL] = ntc_sample[self.config.input.value_col]
                        qaqc_data[SAMPLE_ID_COL] = ntc_sample_id
                        qaqc_data[GENES_COL] = ntc_gene
                        qaqc_data[CELL_A_COL] = None #self.make_cell_link(all_cells, 1)
                        qaqc_data[CELL_B_COL] = None #self.make_cell_link(all_cells, 2)
                        qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=True)
                        qaqc_data[NOTES_COL] = '="Max Ct="&{}'.format(max_formula if not pd.isna(max_formula) else '""')

                        self.qaqc_df = self.qaqc_df.append(qaqc_data, ignore_index=True)

    def qaqc_run_no_detections(self, name):
        all_no_detections_config = self.qaqc_config.get("no_detections", None)
        if all_no_detections_config is None:
            print("WARNING: 'no_detections' does not exist in QAQC config file")
            return

        for no_detections_config in all_no_detections_config:
            individual_columns = no_detections_config.get("individual_columns", False)
            self.qaqc_run_per_sample(name, no_detections_config.genes, MAIN_SHEET, no_detections_config.columns, MAIN_ROW_DATA, None, partial(self.populate_qaqc_no_detections, no_detections_config), accept_blanks=False, mode="flatten" if individual_columns else "separate_groups")

    def populate_qaqc_no_detections(self, detections_info, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
        individual_columns = detections_info.get("individual_columns", False)
        gene = self.get_qaqc_gene_for_column(cur_col, target_sheet_name, row_data[self.config.input.gene_type_col].iloc[0])
        ws, _ = self.populator.get_worksheet_and_info(target_sheet_name)

        if isinstance(cur_col, str):
            cur_col = [cur_col]

        cell_refs = [f"'{ws.title}'!{c}{cur_row}" for c in cur_col]
        formula = [f'{cell_ref}<>""' for cell_ref in cell_refs]
        if len(formula) == 1:
            formula = f'IF({formula[0]}, 1, 0)'
        else:
            # formula = "OR({})".format(",".join(formula))
            formula = "+".join([f'IF({f}, 1, 0)' for f in formula])

        min_detections = 1 if individual_columns else detections_info.min_detections
        formula = f'{formula}>={min_detections}'

        qaqc_data[CELL_A_COL] = self.make_cell_link(cell_refs, type=0)
        qaqc_data[CELL_B_COL] = None
        qaqc_data[CATEGORY_COL] = detections_info.category.format(gene=gene)
        qaqc_data[DESC_COL] = detections_info.description.format(gene=gene)
        qaqc_data[PRIORITY_COL] = detections_info.priority
        # qaqc_data[LOWER_LIMIT_COL] = ", ".join([m if m else "<blank>" for m in matches])
        qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=False, override_formula=formula)
        if not detections_info.get("individual_columns", False):
            qaqc_data[VALUE_COL] = ""

        return True

    def qaqc_run_sample_data_available(self, name):
        samples_info = self.qaqc_config.get("sample_data_available", None)
        if samples_info is None:
            return

        self.qaqc_run_per_sample(name, samples_info.genes, MAIN_SHEET, samples_info.columns, MAIN_ROW_DATA, None, partial(self.populate_qaqc_sample_data_available, samples_info), accept_blanks=False, mode="all_at_once")

    def populate_qaqc_sample_data_available(self, samples_info, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
        gene = self.get_qaqc_gene_for_column(cur_col, target_sheet_name, row_data[self.config.input.gene_type_col].iloc[0])
        ws, _ = self.populator.get_worksheet_and_info(target_sheet_name)

        if isinstance(cur_col, (list, tuple, np.ndarray)):
            if len(cur_col) == 0:
                return False
            cur_col = cur_col[0]

        matches = samples_info.not_available_matches
        cell_ref = f"'{ws.title}'!{cur_col}{cur_row}"
        formula = ['NOT({}={})'.format("{col='Value'}{row}", f"\"{m}\"" if isinstance(m, str) else m) for m in matches]
        formula = "AND({})".format(",".join(formula))

        qaqc_data[CATEGORY_COL] = samples_info.category.format(gene=gene)
        qaqc_data[DESC_COL] = samples_info.description.format(gene=gene)
        qaqc_data[PRIORITY_COL] = samples_info.priority
        qaqc_data[LOWER_LIMIT_COL] = ", ".join([str(m) if m != "" else "<blank>" for m in matches])
        qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=False, override_formula=formula)
        qaqc_data[VALUE_COL] = f"={cell_ref}"

        return True

    def is_in_range(self, value, rng):
        in_range = True
        if rng[0] is not None:
            if value < rng[0]:
                in_range = False
        if rng[1] is not None:
            if value > rng[1]:
                in_range = False
        return in_range

    def qaqc_run_copies_outliers(self, name):
        if "copies_outliers" not in self.qaqc_config:
            return

        for info in self.qaqc_config.copies_outliers:
            columns = info.columns
            if isinstance(columns, str):
                columns = [columns]
            if info.get("use_cal_sheets", False):
                all = self.populator.get_all_cal_worksheets_and_info()
                for ws, ws_info in all:
                    for cur_columns in columns:
                        self.qaqc_run_per_sample(name, [], ws_info["sheet_name"], cur_columns, CAL_ROW_DATA, None, partial(self.populate_qaqc_copies_outliers, info, cur_columns), accept_blanks=True, mode="flatten", fail_if_errors=False)
            else:
                for cur_columns in columns:
                    self.qaqc_run_per_sample(name, [], MAIN_SHEET, cur_columns, MAIN_ROW_DATA, None, partial(self.populate_qaqc_copies_outliers, info, cur_columns), accept_blanks=True, mode="flatten", fail_if_errors=False)
    
    def populate_qaqc_copies_outliers(self, copies_info, column_names, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
        ws, info = self.populator.get_worksheet_and_info(target_sheet_name)
        gene = self.get_qaqc_gene_for_column(cur_col, target_sheet_name, row_data[self.config.input.gene_type_col].iloc[0])
        sample_id = row_data[self.config.input.sample_id_col].iloc[0]

        points_range = self.populator.get_named_range(target_sheet_name, None, column_names, override_row=cur_row, include_sheet_name=True) #, fixed_rows=True, fixed_cols=True, include_sheet_name=False):
        # points_range = [f"'{target_sheet_name}'!{col}{cur_row}" for col in cur_col]
        # points_range = ",".join(points_range)
        stdev = f"STDEV({points_range})"
        avg = f"AVERAGE({points_range})"
        qaqc_data[CATEGORY_COL] = copies_info.category.format(gene=gene)
        qaqc_data[DESC_COL] = copies_info.description.format(gene=gene)
        qaqc_data[PRIORITY_COL] = copies_info.priority
        qaqc_data[LOWER_LIMIT_COL] = f"={avg}-{copies_info.num_stdev}*{stdev}"
        qaqc_data[UPPER_LIMIT_COL] = f"={avg}+{copies_info.num_stdev}*{stdev}"
        # qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=True)
        qaqc_data[NOTES_COL] = f'="Avg="&ROUND({avg},4)&", Stdev="&ROUND({stdev},4)&", MaxStdev="&{copies_info.num_stdev}'

        return True

    def qaqc_run_comparable_genes(self, name):
        if "comparable_genes" not in self.qaqc_config:
            print("WARNING: 'comparable_genes' does not exist in QAQC config file")
            return

        for comp_info in self.qaqc_config.comparable_genes:
            self.qaqc_run_per_sample(name, comp_info.genes[0], MAIN_SHEET, MAIN_COL_CT_AVG, MAIN_ROW_DATA, None, partial(self.populate_qaqc_comparable_genes, comp_info), accept_blanks=False)

    def populate_qaqc_comparable_genes(self, comp_info, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
        _, info = self.populator.get_worksheet_and_info(target_sheet_name)
        gene_a = row_data[self.config.input.gene_type_col].iloc[0]
        gene_b = comp_info.genes[1].strip()
        row_num_a = cur_row
        row_sample_id = row_data[self.config.input.sample_id_col].iloc[0]
        # Find the matching row with the same sample_id but with the second gene
        match_row = add_sheet_name_to_colrow_name(target_sheet_name, MAIN_ROW_DATA)
        column_addr = self.populator.get_named_columns(target_sheet_name, add_sheet_name_to_colrow_name(target_sheet_name, MAIN_COL_CT_AVG), flatten_names=True)
        if len(column_addr) == 0:
            print("WARNING: Could not find columns named '{}' in populate_qaqc_comparable_genes")
            return False
        column_addr = column_addr[0]
        for row_num, (cur_names, cur_data) in enumerate(zip(info["row_names"], info["row_data"])):
            if match_row in cur_names:
                for check_data in cur_data:
                    cur_gene = check_data[self.config.input.gene_type_col].iloc[0].strip().lower()
                    cur_sample_id = check_data[self.config.input.sample_id_col].iloc[0]
                    if cur_sample_id == row_sample_id and cur_gene.lower() == gene_b.lower():
                        row_num_b = row_num + info["origin"][0]

                        cell_ref_a = f"'{target_sheet_name}'!{column_addr}{row_num_a}"
                        cell_ref_b = f"'{target_sheet_name}'!{column_addr}{row_num_b}"

                        qaqc_data[CATEGORY_COL] = comp_info.category.format(gene_a=gene_a, gene_b=gene_b)
                        qaqc_data[DESC_COL] = comp_info.description.format(gene_a=gene_a, gene_b=gene_b)
                        qaqc_data[PRIORITY_COL] = comp_info.priority
                        qaqc_data[CELL_A_COL] = self.make_cell_link(cell_ref_a)
                        qaqc_data[CELL_B_COL] = self.make_cell_link(cell_ref_b)
                        qaqc_data[VALUE_COL] = f"=ABS({cell_ref_a}-{cell_ref_b})"
                        value_ref = "{col='Value'}{row}"
                        value_ref = parse_colrow_tags(value_ref, self.qaqc_df, self.get_next_qaqc_row())                        
                            
                        depth = 0
                        upper_range_formula = ""

                        for range in comp_info.ranges:
                            cur_range_formula = self.excel_range_check_formula(range.ct_range_filter, [cell_ref_a, cell_ref_b], "AND" if range.requires == "all" else "OR")
                            upper_range_formula = f"{upper_range_formula}IF({cur_range_formula}, {range.abs_diff_max}, "
                            depth += 1
                        upper_range_formula = "{}ERROR{}".format(upper_range_formula, ")" * depth)
                        qaqc_data[UPPER_LIMIT_COL] = f"={upper_range_formula}"
                        qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=False)
                        qaqc_data[NOTES_COL] = f"=\"Value is ABS(\"&ROUND({cell_ref_a},4)&\"-\"&ROUND({cell_ref_b},4)&\")\""

                        return True
        return False

    def qaqc_run_inhibition(self, name):
        if "inhibitions" not in self.qaqc_config:
            print("WARNING: 'inhibition' does not exist in QAQC config file")
            return

        inhibitions = self.qaqc_config.inhibitions
        for inhibition in inhibitions:
            self.qaqc_run_value_in_range(name, inhibition, MAIN_SHEET)

    def qaqc_run_non_detects(self, name):
        if "non_detects" not in self.qaqc_config:
            print("WARNING: 'non_detects' does not exist in QAQC config file")
            return

        non_detects = self.qaqc_config.non_detects

        for non_detect in non_detects:
            sheets = non_detect.sheets
            if isinstance(sheets, str):
                sheets = [sheets]
            
            if "main" in sheets:
                self.qaqc_run_value_match(name, non_detect, MAIN_SHEET)
            if "cal" in sheets:
                all_info = self.populator.get_all_cal_worksheets_and_info()
                for info in all_info:
                    self.qaqc_run_value_match(name, non_detect, info[1]["sheet_name"])

    # def populate_qaqc_inhibition(self, inhibition_info, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
    #     gene = self.get_qaqc_gene_for_column(cur_col, target_sheet_name, row_data[self.config.input.gene_type_col].iloc[0])
    #     if inhibition_info.mode == "2col":
    #         cell_ref_a = f"'{target_sheet_name}'!{cur_col[0]}{cur_row}"
    #         cell_ref_b = f"'{target_sheet_name}'!{cur_col[1]}{cur_row}"
    #         qaqc_data[NOTES_COL] = f"=\"Value is ABS(\"&ROUND({cell_ref_a},4)&\"-\"&ROUND({cell_ref_b},4)&\")\""
    #         qaqc_data[VALUE_COL] = f"=IF(AND(ISNUMBER({cell_ref_a}), ISNUMBER({cell_ref_b})), ABS({cell_ref_a}-{cell_ref_b}), \"\")"
    #     elif inhibition_info.mode == "1col":
    #         cell_ref_a = f"'{target_sheet_name}'!{cur_col}{cur_row}"
    #         qaqc_data[VALUE_COL] = QAQC_VALUE_FORMULA.format(cell_ref=cell_ref_a)

    #     qaqc_data[CATEGORY_COL] = inhibition_info.category.format(gene=gene)
    #     qaqc_data[DESC_COL] = inhibition_info.description.format(gene=gene)
    #     qaqc_data[PRIORITY_COL] = inhibition_info.priority
    #     return True

    def qaqc_run_value_in_range(self, name, config, sheet_name):
        row_name = MAIN_ROW_DATA if sheet_name == MAIN_SHEET else CAL_ROW_DATA
        self.qaqc_run_per_sample(name, config.get("genes", []), sheet_name, config.columns, row_name, config.range, partial(self.populate_qaqc_value_in_range, config), accept_blanks=config.get("accept_blanks", True), mode="flatten")

    def populate_qaqc_value_in_range(self, range_config, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
        gene = self.get_qaqc_gene_for_column(cur_col, target_sheet_name, row_data[self.config.input.gene_type_col].iloc[0])
        qaqc_data[CATEGORY_COL] = range_config.category.format(gene=gene, range=rng)
        qaqc_data[DESC_COL] = range_config.description.format(gene=gene, range=rng)
        qaqc_data[PRIORITY_COL] = range_config.priority
        return True

    def qaqc_run_value_match(self, name, config, sheet_name):
        row_name = MAIN_ROW_DATA if sheet_name == MAIN_SHEET else CAL_ROW_DATA
        self.qaqc_run_per_sample(name, config.get("genes", []), sheet_name, config.columns, row_name, None, partial(self.populate_qaqc_value_match, config), accept_blanks=True, mode="flatten")

    def populate_qaqc_value_match(self, match_config, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
        bad_matches = match_config.get("bad_matches", None)
        good_matches = match_config.get("good_matches", None)
        gene = self.get_qaqc_gene_for_column(cur_col, target_sheet_name, row_data[self.config.input.gene_type_col].iloc[0])
        qaqc_data[CATEGORY_COL] = match_config.category.format(gene=gene)
        qaqc_data[DESC_COL] = match_config.description.format(gene=gene)
        qaqc_data[PRIORITY_COL] = match_config.priority

        value_cell = parse_colrow_tags("{col='Value'}{row}", self.qaqc_df, self.get_next_qaqc_row())
        good_formulas = []
        bad_formulas = []
        info = []
        for idx, matches in enumerate((good_matches, bad_matches)):
            if matches is None:
                continue
            for match in matches:
                try:
                    match_val = float(match_val)
                except:
                    match_val = str(match).replace('"', '""')
                    match_val = f'"{match_val}"'
                current_expr = f"{value_cell}={match_val}"
                if idx == 0:
                    good_formulas.append(current_expr)
                    info.append(f"{match}")
                else:
                    bad_formulas.append(current_expr)
                    info.append(f"!{match}")

        exprs = []
        if len(good_formulas) == 0:
            good_formulas.append("TRUE")
        if len(bad_formulas) == 0:
            bad_formulas.append("FALSE")
        exprs.append("OR({})".format(",".join(good_formulas)))
        exprs.append("NOT(OR({}))".format(",".join(bad_formulas)))
        full_expr = "AND({})".format(",".join(exprs)) if len(exprs) > 0 else "TRUE"
        
        qaqc_data[LOWER_LIMIT_COL] = "Matches={}".format(",".join(info))
        qaqc_data[UPPER_LIMIT_COL] = None
        qaqc_data[VALIDATES_COL] = f"={full_expr}"
        return True

    def qaqc_run_loq(self, name):
        if "loq" not in self.qaqc_config:
            print("WARNING: 'loq' does not exist in QAQC config file")
            return

        for loq_config in self.qaqc_config.loq:
            self.qaqc_run_per_sample(name, loq_config.genes, MAIN_SHEET, loq_config.columns, MAIN_ROW_DATA, loq_config.copies_per_well_range, partial(self.populate_qaqc_loq, loq_config), accept_blanks=True)

    def populate_qaqc_loq(self, loq_config, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
        gene = self.get_qaqc_gene_for_column(cur_col, target_sheet_name, row_data[self.config.input.gene_type_col].iloc[0])
        qaqc_data[CATEGORY_COL] = loq_config.category.format(gene=gene)
        qaqc_data[DESC_COL] = loq_config.description.format(gene=gene)
        qaqc_data[PRIORITY_COL] = loq_config.priority
        return True

    def qaqc_run_check_ct_stdev(self, name):
        all_main_ct_outliers = self.qaqc_config.get("main_ct_outliers", None)
        all_cal_ct_outliers = self.qaqc_config.get("cal_ct_outliers", None)

        check = [(all_main_ct_outliers, MAIN_SHEET, MAIN_ROW_DATA)]
        all_cal = self.get_all_cal_worksheets_and_info()
        check.extend([(all_cal_ct_outliers, info["sheet_name"], CAL_ROW_DATA) for _, info in all_cal])

        for all_ct_outliers, sheet_name, row_name in check:
            if all_ct_outliers is None:
                continue

            for ct_outliers in all_ct_outliers:
                rng = ct_outliers.get("range", None)
                if rng is None:
                    rng = [None, ct_outliers.max_stdev]
                # For standard deviation
                if ct_outliers.get("max_stdev", None) is not None:
                    self.qaqc_run_per_sample(name, [], sheet_name, ct_outliers.columns, row_name, rng, partial(self.populate_qaqc_check_ct_stdev, ct_outliers), accept_blanks=True, mode="separate_groups")
                # For range
                if ct_outliers.get("range", None) is not None:
                    self.qaqc_run_per_sample(name, [], sheet_name, ct_outliers.columns, row_name, rng, partial(self.populate_qaqc_check_ct_range, ct_outliers), accept_blanks=True, mode="flatten")

    def populate_qaqc_check_ct_stdev(self, outliers_info, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
        ws, _ = self.populator.get_worksheet_and_info(target_sheet_name)
        all_cells = [f"'{ws.title}'!{c}{cur_row}" for c in cur_col]
        all_cells_str = ",".join(all_cells)
        stdev_formula = "STDEV({})".format(all_cells_str)
        qaqc_data[CATEGORY_COL] = outliers_info.category.format(max_stdev=outliers_info.get("max_stdev", None), range=outliers_info.get("range", None))
        qaqc_data[DESC_COL] = outliers_info.description.format(max_stdev=outliers_info.get("max_stdev", None), range=outliers_info.get("range", None))
        qaqc_data[PRIORITY_COL] = outliers_info.priority
        qaqc_data[CELL_A_COL] = self.make_cell_link(all_cells, 0)
        qaqc_data[CELL_B_COL] = None
        qaqc_data[VALUE_COL] = f"=IF(COUNT({all_cells_str})>1, {stdev_formula}, 0)"
        qaqc_data[GENES_COL] = None
        qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=True)
        return True

    def populate_qaqc_check_ct_range(self, outliers_info, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
        ws, _ = self.populator.get_worksheet_and_info(target_sheet_name)
        all_cells = [f"'{ws.title}'!{c}{cur_row}" for c in cur_col]
        all_cells_str = ",".join(all_cells)
        # stdev_formula = "STDEV({})".format(all_cells_str)
        qaqc_data[CATEGORY_COL] = outliers_info.category.format(max_stdev=outliers_info.get("max_stdev", None), range=outliers_info.get("range", None))
        qaqc_data[DESC_COL] = outliers_info.description.format(max_stdev=outliers_info.get("max_stdev", None), range=outliers_info.get("range", None))
        qaqc_data[PRIORITY_COL] = outliers_info.priority
        qaqc_data[CELL_A_COL] = self.make_cell_link(all_cells, 0)
        qaqc_data[CELL_B_COL] = None
        # qaqc_data[VALUE_COL] = f"=IF(COUNT({all_cells_str})>1, {stdev_formula}, 0)"
        qaqc_data[GENES_COL] = None
        qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=True)
        return True

    def qaqc_run_baseline_in_range(self, name):
        if "baseline_ct_range" not in self.qaqc_config:
            print("WARNING: 'baseline_ct_range' does not exist in QAQC config file")
            return

        # rng = self.qaqc_config.baseline_ct_range.ranges.get(self.qaqc_config.site, None)
        # if rng is None:
        #     print(f"WARNING: No baseline_ct_range in QAQC config for site '{self.qaqc_config.site}'")
        #     return

        self.qaqc_run_per_sample(name, [], MAIN_SHEET, MAIN_COL_BL_CT, MAIN_ROW_DATA, None, partial(self.populate_qaqc_data_baseline_in_range, self.qaqc_config.baseline_ct_range), accept_blanks=True)

    def populate_qaqc_data_baseline_in_range(self, baseline_info, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
        # row_gene = row_data[self.config.input.gene_type_col].iloc[0]
        site_id = row_data[f"{self.config.input.sample_sheet_name}_{self.config.input.site_id_col}"].iloc[0] or "<default>"
        site_id = site_id.replace(f"{self.populator.config.input.lab_id}{self.populator.config.input.lab_id_separator}", "")
        if site_id not in baseline_info.ranges.keys():
            # @TODO: Readd this informational output
            # print(f"Unrecognized site for QA/QC baseline_ct_range: {site_id}")
            return False

        rng = baseline_info.ranges[site_id]
        qaqc_data[LOWER_LIMIT_COL] = rng[0]
        qaqc_data[UPPER_LIMIT_COL] = rng[1]

        gene = baseline_info.gene
        qaqc_data[CATEGORY_COL] = baseline_info.category.format(gene=gene, site=site_id)
        qaqc_data[DESC_COL] = baseline_info.description.format(gene=gene, site=site_id)
        qaqc_data[PRIORITY_COL] = baseline_info.priority
        qaqc_data[GENES_COL] = gene
        return True

    def get_first_and_last_average_standard_cells(self, standard_curve_id):
        cal_sheet_name = standard_curve_id #CAL_SHEET_FMT.format(gene=gene, plateID=plate_id)
        cell_id_format = "avg_std_{}"
        num = 0
        first_std = None
        last_std = None
        while True:
            cell_id = cell_id_format.format(num)
            try:
                cell_ref = self.populator.get_named_cell_address_or_value(cal_sheet_name, cell_id, prefer_precalculated=False)
            except:
                cell_ref = None
            if cell_ref is None:
                break
            if first_std is None:
                first_std = cell_ref
            last_std = cell_ref
            num = num + 1

        return first_std, last_std

    def qaqc_run_samples_within_standard_curves(self, name):
        if "standard_curves" not in self.qaqc_config:
            print("WARNING: 'standard_curves' does not exist in QAQC config file")
            return
        if "samples_within_calibration_curve" not in self.qaqc_config.standard_curves:
            print("WARNING: 'standard_curves.samples_within_calibration_curve' does not exist in QAQC config file")
            return

        for cal_info in self.qaqc_config.standard_curves.samples_within_calibration_curve:
            cur_genes = cal_info.genes
            if cur_genes is not None:
                cur_genes = [g.strip() for g in cal_info.genes]
            self.qaqc_run_per_sample(name, cur_genes, MAIN_SHEET, cal_info.columns, MAIN_ROW_DATA, None, partial(self.populate_qaqc_samples_within_standard_curves, cal_info), mode="all_at_once")
            
    def populate_qaqc_samples_within_standard_curves(self, cal_info, target_sheet_name, qaqc_data, row_data, name, rng, cur_row, cur_col):
        accept_blanks = False
        ws, info = self.populator.get_worksheet_and_info(target_sheet_name)
        main_gene = row_data[self.config.input.gene_type_col].iloc[0]
        sample_id = row_data[self.config.input.sample_id_col].iloc[0]
        bl_cols = cal_info.get("baseline_columns", None)
        if bl_cols is not None:
            bl_cols = [add_sheet_name_to_colrow_name(target_sheet_name, c) for c in cal_info.baseline_columns]
            bl_cols = self.populator.get_named_columns(target_sheet_name, bl_cols, flatten_names=True)
        # Do both the main columns (cur_col) and the baseline columns (bl_cols)
        for check_cols, _gene in zip([cur_col, bl_cols], [main_gene, cal_info.baseline_gene]):
            if check_cols is None:
                continue
            for col in check_cols:
                gene = self.get_qaqc_gene_for_column(col, target_sheet_name, _gene)

                cell_ref = f"{col}{cur_row}"
                plate_id = self.populator.get_cell_standard_curve_id(ws[cell_ref])

                if plate_id is None:
                    continue

                first_std, last_std = self.get_first_and_last_average_standard_cells(plate_id)

                if first_std is None:
                    continue
                
                cell_ref = f"'{ws.title}'!{cell_ref}"
                qaqc_data[CATEGORY_COL] = cal_info.category.format(gene=gene)
                qaqc_data[DESC_COL] = cal_info.description.format(gene=gene)
                qaqc_data[PRIORITY_COL] = cal_info.priority
                qaqc_data[GROUP_COL] = name
                qaqc_data[GENES_COL] = gene
                qaqc_data[LOWER_LIMIT_COL] = f"={first_std}" if isinstance(first_std, str) else first_std
                qaqc_data[UPPER_LIMIT_COL] = f"={last_std}" if isinstance(last_std, str) else last_std
                # qaqc_data[VALUE_COL] = f"=IF(ISNUMBER({cell_ref}), {cell_ref}, \"\")"
                qaqc_data[VALUE_COL] = QAQC_VALUE_FORMULA.format(cell_ref=cell_ref)
                qaqc_data[CELL_A_COL] = self.make_cell_link(cell_ref)
                qaqc_data[CELL_B_COL] = None
                qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=accept_blanks)
                self.qaqc_df = self.qaqc_df.append(qaqc_data, ignore_index=True)
        
        return False

    def get_qaqc_gene_for_column(self, col_ids, sheet_name, default_gene):
        column_genes = self.qaqc_config.get("column_genes", None)
        if not column_genes or len(column_genes.keys()) == 0:
            return default_gene

        if isinstance(col_ids, str):
            col_id = col_ids
        else:
            if len(col_ids) == 0:
                return default_gene
            col_id = col_ids[0]
            while isinstance(col_id, (list, tuple, np.ndarray)):
                col_id = col_id[0]
        
        column_names = self.populator.get_column_names(sheet_name, col_id)
        column_names = [c[len(sheet_name)+1:] for c in column_names]
        matches = [gene for gene, cs in column_genes.items() if len(set(column_names).intersection(set(cs))) > 0]
        if len(matches) == 0:
            return default_gene
        elif len(matches) > 1:
            raise ValueError(f"Multiple gene matches for column '{col_id}' in qaqc_config.column_genes: {matches}")
        
        # print(f"Matched {col_ids} with {matches[0]}")
        return matches[0]

    def qaqc_run_standard_curve_inter_comparisons(self, name):
        if "standard_curves" not in self.qaqc_config:
            print("WARNING: 'standard_curves' does not exist in QAQC config file")
            return
        if "inter_comparisons" not in self.qaqc_config.standard_curves:
            print("WARNING: 'standard_curves.inter_comparisons' does not exist in QAQC config file")
            return

        for comp in self.qaqc_config.standard_curves.inter_comparisons:
            qaqc_data = DEFAULT_QAQC_DATA.copy()
            
            gene_a, gene_b = comp.genes

            pairs = self.populator.get_all_paired_cal_sheets(gene_a, gene_b)

            # sheet_name_a = CAL_SHEET_FMT.format(gene_a)
            # sheet_name_b = CAL_SHEET_FMT.format(gene_b)
            # _, info_a = self.populator.get_worksheet_and_info(sheet_name_a)
            # _, info_b = self.populator.get_worksheet_and_info(sheet_name_b)

            # if info_a is None and info_b is None:
            #     continue

            for info_a, info_b in pairs:
                sheet_name_a = info_a["sheet_name"]
                sheet_name_b = info_b["sheet_name"]
                qaqc_data[GENES_COL] = ",".join(comp.genes)
                for num, abs_diff_max in enumerate(comp.abs_diff_max):
                    format_vars = {
                        "gene_a" : gene_a,
                        "gene_b" : gene_b,
                        "std_num" : num+1,
                    }
                    qaqc_data[CATEGORY_COL] = comp.category.format(**format_vars)
                    qaqc_data[DESC_COL] = comp.description.format(**format_vars)
                    qaqc_data[PRIORITY_COL] = comp.priority
                    qaqc_data[GROUP_COL] = name
                    qaqc_data[LOWER_LIMIT_COL] = None
                    qaqc_data[UPPER_LIMIT_COL] = abs_diff_max
                    qaqc_data[VALUE_COL] = None
                    qaqc_data[CELL_A_COL] = None
                    qaqc_data[CELL_B_COL] = None
                    id = f"avg_std_{num}"

                    try:
                        cell_ref_a = self.populator.get_named_cell_address_or_value(sheet_name_a, id, prefer_precalculated=False)
                        cell_ref_b = self.populator.get_named_cell_address_or_value(sheet_name_b, id, prefer_precalculated=False)
                        qaqc_data[VALUE_COL] = "=ABS({}-{})".format(cell_ref_a, cell_ref_b)
                        qaqc_data[CELL_A_COL] = self.make_cell_link(cell_ref_a)
                        qaqc_data[CELL_B_COL] = self.make_cell_link(cell_ref_b)
                    except:
                        pass
                    if qaqc_data[VALUE_COL] is not None:
                        qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=False)
                    else:
                        qaqc_data[VALUE_COL] = "MISSING"
                        qaqc_data[VALIDATES_COL] = False
                    self.qaqc_df = self.qaqc_df.append(qaqc_data, ignore_index=True)

    def qaqc_run_standard_curves(self, name):        
        if "standard_curves" not in self.qaqc_config:
            print("WARNING: 'standard_curves' does not exist in QAQC config file")
            return
        if "curves" not in self.qaqc_config.standard_curves:
            print("WARNING: 'standard_curves.curves' does not exist in QAQC config file")
            return

        for curve in self.qaqc_config.standard_curves.curves:
            qaqc_data = DEFAULT_QAQC_DATA.copy()
            qaqc_data[GROUP_COL] = name
            for gene in curve.genes:
                sheets = self.populator.get_cal_sheets_by_gene(gene, no_qaqc_only=True)
                for info in sheets:
                    # sheet_name = CAL_SHEET_FMT.format(gene)
                    sheet_name = info["sheet_name"]
                    # _, info = self.populator.get_worksheet_and_info(sheet_name)
                    if info is None:
                        continue
                    qaqc_data[GENES_COL] = gene

                    # Add rsq, slope, and intercept
                    params = []
                    if "rsq_range" in curve:
                        params += [(curve.rsq_description, curve.rsq_priority, "rsq", curve.rsq_range)]
                    if "slope_range" in curve:
                        params += [(curve.slope_description, curve.slope_priority, "slope", curve.slope_range)]
                    if "intercept_range" in curve:
                        params += [(curve.intercept_description, curve.intercept_priority, "intercept", curve.intercept_range)]
                    for desc, priority, id, rng in params:
                        qaqc_data[CATEGORY_COL] = curve.category.format(gene=gene)
                        qaqc_data[DESC_COL] = desc.format(gene=gene)
                        qaqc_data[PRIORITY_COL] = priority
                        qaqc_data[LOWER_LIMIT_COL] = rng[0] if rng is not None else None
                        qaqc_data[UPPER_LIMIT_COL] = rng[1] if rng is not None else None
                        qaqc_data[VALUE_COL] = None
                        qaqc_data[CELL_A_COL] = None
                        qaqc_data[CELL_B_COL] = None

                        try:
                            cell_ref = self.populator.get_named_cell_address_or_value(sheet_name, id, prefer_precalculated=False)
                            qaqc_data[VALUE_COL] = "={}".format(cell_ref)
                            qaqc_data[CELL_A_COL] = self.make_cell_link(cell_ref)
                        except Exception as e:
                            pass
                        if qaqc_data[VALUE_COL] is not None:
                            qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=False)
                        else:
                            qaqc_data[VALUE_COL] = "MISSING"
                            qaqc_data[VALIDATES_COL] = False
                        self.qaqc_df = self.qaqc_df.append(qaqc_data, ignore_index=True)

                    # Check if each standard replicates average is in range
                    if "average_replicates_range" in curve:
                        for num, rng in enumerate(curve.average_replicates_range):
                            qaqc_data[CATEGORY_COL] = curve.category.format(gene=gene)
                            qaqc_data[DESC_COL] = curve.replicates_description.format(gene=gene, std_num=num+1)
                            qaqc_data[PRIORITY_COL] = curve.replicates_priority
                            qaqc_data[LOWER_LIMIT_COL] = rng[0] if rng is not None else None
                            qaqc_data[UPPER_LIMIT_COL] = rng[1] if rng is not None else None
                            qaqc_data[VALUE_COL] = None
                            qaqc_data[CELL_A_COL] = None
                            qaqc_data[CELL_B_COL] = None
                            id = f"avg_std_{num}"

                            try:
                                cell_ref = self.populator.get_named_cell_address_or_value(sheet_name, id, prefer_precalculated=False)
                                qaqc_data[VALUE_COL] = "={}".format(cell_ref)
                            except:
                                cell_ref = None
                            if cell_ref is not None and not isinstance(cell_ref, (float, int)):
                                qaqc_data[CELL_A_COL] = self.make_cell_link(cell_ref)
                            if qaqc_data[VALUE_COL] is not None:
                                qaqc_data[VALIDATES_COL] = self.get_validates_formula(accept_blanks=False)
                            else:
                                qaqc_data[VALUE_COL] = "MISSING"
                                qaqc_data[VALIDATES_COL] = False
                            self.qaqc_df = self.qaqc_df.append(qaqc_data, ignore_index=True)

    def qaqc_highlight_outliers(self):
        main_ws, main_info = self.populator.get_worksheet_and_info(MAIN_SHEET)

        all_main_ct_outliers = self.qaqc_config.get("main_ct_outliers", None)
        all_cal_ct_outliers = self.qaqc_config.get("cal_ct_outliers", None)
        all_outlier_columns = []
        if all_main_ct_outliers is not None:
            for main_ct_outliers in all_main_ct_outliers:
                outlier_columns = self.populator.get_named_columns(MAIN_SHEET, [add_sheet_name_to_colrow_name(MAIN_SHEET, c) for c in main_ct_outliers.columns], flatten_names=True)
                outlier_columns = flatten(outlier_columns)
                all_outlier_columns.append({
                    "info" : main_info,
                    "columns" : outlier_columns,
                    "config" : main_ct_outliers,
                    "rows" : MAIN_ROW_DATA,
                })
        if all_cal_ct_outliers is not None:
            for cal_ct_outliers in all_cal_ct_outliers:
                all_cal = self.populator.get_all_cal_worksheets_and_info()
                for cal_ws, cal_info in all_cal:
                    cal_columns = self.populator.get_named_columns(cal_info["sheet_name"], [add_sheet_name_to_colrow_name(cal_info["sheet_name"], c) for c in cal_ct_outliers.columns], flatten_names=True)
                    cal_columns = flatten(cal_columns)
                    all_outlier_columns.append({
                        "info" : cal_info,
                        "columns" : cal_columns,
                        "config" : cal_ct_outliers,
                        "rows" : CAL_ROW_DATA,
                    })
        if len(all_outlier_columns) > 0:
            for cur_data in all_outlier_columns:
                info = cur_data["info"]
                columns = cur_data["columns"]
                outliers_config = cur_data["config"]
                first_row = info["origin"][0]
                # first_col = get_column_letter(info["origin"][1])
                # last_col = get_column_letter(info["extents"][1]-1)
                target_rows = add_sheet_name_to_colrow_name(info["sheet_name"], cur_data["rows"])
                for idx, (data, row_names) in enumerate(zip(info["row_data"], info["row_names"])):
                    if target_rows in row_names:
                        current_row = idx+first_row
                        for column in columns:
                            target_cell = f"{column}{current_row}"
                            r = Rule(type="expression", dxf=self.styles[outliers_config.priority]["dxf"], stopIfTrue=False)
                            r.formula=[f'LEFT({target_cell}&"")="["']
                            # info["ws"].conditional_formatting.add(target_cell, r)
                            self.append_formatting_rule(info["ws"], outliers_config.priority, target_cell, r)

    def qaqc_higlight_conditional_formatting(self):
        all_formatting = self.qaqc_config.get("conditional_formatting", None)
        if all_formatting is None:
            return
        
        main_ws, main_info = self.populator.get_worksheet_and_info(MAIN_SHEET)
        first_row = main_info["origin"][0]

        for formatting in all_formatting:
            test =  formatting.test
            target_rows = add_sheet_name_to_colrow_name(MAIN_SHEET, MAIN_ROW_DATA)
            for idx, (data, row_names) in enumerate(zip(main_info["row_data"], main_info["row_names"])):
                if target_rows in row_names:
                    current_row = idx+first_row
                    format_columns = [parse_colrow_tags(c, self.populator.main_columns, cur_row=current_row) for c in formatting.format_columns]
                    formula = parse_colrow_tags(test, self.populator.main_columns, cur_row=current_row)
                    r = Rule(type="expression", dxf=self.styles[formatting.priority]["dxf"], stopIfTrue=False)
                    r.formula = [formula]
                    for column in format_columns:
                        # main_ws.conditional_formatting.add(column, r)
                        self.append_formatting_rule(main_ws, formatting.priority, column, r)

    def qaqc_highlight_no_detections_rows(self):
        all_no_detections_config = self.qaqc_config.get("no_detection_rows", None)
        if all_no_detections_config is None:
            return

        main_ws, main_info = self.populator.get_worksheet_and_info(MAIN_SHEET)
        if main_info["extents"][1]-1 == 0:
            return

        for no_detections_config in all_no_detections_config:
            # if no_detections_config.get("individual_columns", False):
            #     continue
            individual_columns = no_detections_config.get("individual_columns", False)

            no_detection_columns = no_detections_config.get("columns", None)
            if isinstance(no_detection_columns, str):
                no_detection_columns = [no_detection_columns]
            
            if no_detection_columns is None:
                return

            for column_name in no_detection_columns:
                cur_cols = self.populator.get_named_columns(MAIN_SHEET, add_sheet_name_to_colrow_name(MAIN_SHEET, column_name), flatten_names=True)

                if cur_cols is not None and len(cur_cols) > 0:
                    first_row = main_info["origin"][0]
                    first_col = get_column_letter(main_info["origin"][1])
                    last_col = get_column_letter(main_info["extents"][1]-1)
                    target_rows = add_sheet_name_to_colrow_name(MAIN_SHEET, MAIN_ROW_DATA)

                    if individual_columns:
                        pass
                    else:
                        cur_cols = [cur_cols]
                    for cur_col in cur_cols:
                        for idx, (data, row_names) in enumerate(zip(main_info["row_data"], main_info["row_names"])):
                            if target_rows in row_names:
                                current_row = idx+first_row
                                if individual_columns:
                                    target_range = f"{cur_col}{current_row}"
                                else:
                                    target_range = f"{first_col}{current_row}:{last_col}{current_row}"
                                r = Rule(type="expression", dxf=self.styles[no_detections_config.priority]["dxf"], stopIfTrue=False)
                                formula = [f'${col}${current_row}<>""' for col in cur_col]
                                formula = [f'IF({f}, 1, 0)' for f in formula]
                                formula = "+".join(formula)
                                formula = f'{formula}<{no_detections_config.min_detections}'
                                # formula = "AND({})".format(",".join(formula))
                                r.formula = [formula]
                                # main_ws.conditional_formatting.add(target_range, r)
                                self.append_formatting_rule(main_ws, no_detections_config.priority, target_range, r)

    def append_custom_formatting_rule(self, ws, prio, target_range, formula):
        r = Rule(type="expression", dxf=self.styles[prio]["dxf"], stopIfTrue=False)
        r.formula = [formula]
        # main_ws.conditional_formatting.add(target_range, r)
        self.append_formatting_rule(ws, prio, target_range, r)

    def append_formatting_rule(self, ws, prio, target_range, rule):
        if prio not in self.formatting_rules:
            self.formatting_rules[prio] = []
        self.formatting_rules[prio].append({
            "ws" : ws,
            "target_range" : target_range,
            "rule" : rule,
        })

    def apply_formatting_rules(self):
        if len(self.formatting_rules) == 0:
            return

        def _apply(rule):
            rule["ws"].conditional_formatting.add(rule["target_range"], rule["rule"])

        # Formatting added first is applied last (has higher precedence)

        # Apply known priorities
        for prio_info in self.qaqc_config.qaqc_priorities:
            if prio_info["name"] in self.formatting_rules:
                for rule in self.formatting_rules[prio_info["name"]]:
                    _apply(rule)

        # Apply unknown priorities (ie. not in the config file)
        known_prios = [info["name"] for info in self.qaqc_config.qaqc_priorities]
        for prio_key, prio_info in self.formatting_rules.items():
            if prio_key in known_prios:
                continue
            for rule in self.formatting_rules[prio_key]:
                _apply(rule)

        self.formatting_rules = {}

    def prepare_styles(self):
        # Create styles/colors for the different QAQC priority levels
        styles = {}
        colors = {info["name"] : info for info in self.qaqc_config.qaqc_priorities}
        for prio, cols in colors.items():
            styles[prio] = {}
            styles[prio]["fill"] = PatternFill(bgColor=cols["fill"])
            styles[prio]["font"] = Font(color=cols["font"], bold=cols["bold"])
            styles[prio]["dxf"] = DifferentialStyle(fill=styles[prio]["fill"], font=styles[prio]["font"])

        self.styles = styles

    def add_qaqc_to_workbook(self, wb, name=None):
        if name is not None:
            self.set_current_name(name)

        if not self.has_qaqc():
            return

        # Make a new sheet and copy data over from qaqc_df
        ws = None
        if len(self.qaqc_df.index) > 0:
            sheet_name = self.get_sheet_name()
            if DELETE_EXISTING_SHEET:
                if sheet_name in wb.sheetnames:
                    wb.remove(wb[sheet_name])
            else:
                num = 2
                sheet_name_template = sheet_name
                while sheet_name in wb.sheetnames:
                    sheet_ver = get_column_letter(num).lower()
                    sheet_name = f"{sheet_name_template}-{sheet_ver}"
            ws = wb.create_sheet(sheet_name)

            main_ws, main_info = self.populator.get_worksheet_and_info(MAIN_SHEET)
            ws = self.output_wb[sheet_name]
            ws.freeze_panes = "A2"

            # Add all the rows from QAQC DataFrame
            for r in dataframe_to_rows(self.qaqc_df, index=False, header=True):
                ws.append(r)
        
        if len(self.qaqc_df.index) > 0:
            # Add hyperlinks to CELL_A_COL and CELL_B_COL columns in QAQC sheet
            col_id_a = get_column_letter(self.qaqc_df.columns.tolist().index(CELL_A_COL)+1)
            col_id_b = get_column_letter(self.qaqc_df.columns.tolist().index(CELL_B_COL)+1)
            for col_id in [col_id_a, col_id_b]:
                for cell in ws[f"{col_id}:{col_id}"]:
                    if isinstance(cell.value, str) and re.search("=[\s]*hYPERLINK[\s]*\(", cell.value, re.IGNORECASE) is not None:
                        cell.style = "Hyperlink"
        

            val_col = get_column_letter(self.qaqc_df.columns.tolist().index(VALIDATES_COL)+1)
            priority_col = get_column_letter(self.qaqc_df.columns.tolist().index(PRIORITY_COL)+1)

            # Highlight all rows in QAQC sheet with FALSE in the Validates column
            for prio, style in self.styles.items():
                r = Rule(type="expression", dxf=style["dxf"], stopIfTrue=False)
                r.formula = [f'AND(NOT(${val_col}2),${priority_col}2="{prio}")']
                max_col = get_column_letter(len(self.qaqc_df.columns))
                max_row = len(self.qaqc_df.index) + 1
                # ws.conditional_formatting.add(f"A2:{max_col}{max_row}", r)
                self.append_formatting_rule(ws, prio, f"A2:{max_col}{max_row}", r)
                ws.number_format = "#.##"
            
            # Conditional formatting for target cells that are invalid. We check the Validates column and
            # if FALSE we mark change coloring of the target cell
            cell_a_col = get_column_letter(self.qaqc_df.columns.tolist().index(CELL_A_COL)+1)
            cell_b_col = get_column_letter(self.qaqc_df.columns.tolist().index(CELL_B_COL)+1)
            for rng in [ws[f"{cell_a_col}2:{cell_a_col}{max_row}"], ws[f"{cell_b_col}2:{cell_b_col}{max_row}"]]:
                for cell in rng:
                    # eg: =HYPERLINK("#'Main'!D33", "'Main'!D33")
                    # We will retrieve the first parameter, which is the actual link
                    cell = cell[0]
                    if cell.value is None:
                        continue

                    res = re.search('"(?=[^#,])([^"]*)"\)', cell.value)
                    if not res:
                        continue
                    cell_refs = [r.strip() for r in res[1].split(",")]
                    
                    for ref in cell_refs:
                        target_sheet, target_cell = ref.split("!")
                        target_sheet = target_sheet.strip("'")

                        for prio, style in self.styles.items():
                            r = Rule(type="expression", dxf=style["dxf"], stopIfTrue=False)
                            # formula = f"AND(NOT('{sheet_name}'!${val_col}${cell.row}),'{sheet_name}'!${priority_col}${cell.row}=\"{prio}\")"
                            val_cell = f"'{sheet_name}'!${val_col}${cell.row}"
                            prio_cell = f"'{sheet_name}'!${priority_col}${cell.row}"
                            # indirect_val_cell = f"INDIRECT(\"'{sheet_name}'!\"&ADDRESS(ROW({val_cell}),COLUMN({val_cell})))"
                            # indirect_prio_cell = f"INDIRECT(\"'{sheet_name}'!\"&ADDRESS(ROW({prio_cell}), COLUMN({prio_cell})))"
                            formula = f"AND(NOT({val_cell}),{prio_cell}=\"{prio}\")"
                            # formula = f"AND(NOT({indirect_val_cell}),{indirect_prio_cell}=\"{prio}\")"
                            r.formula = [formula]
                            target_ws = self.output_wb[target_sheet]
                            # target_ws.conditional_formatting.add(target_cell, r)
                            self.append_formatting_rule(target_ws, prio, target_cell, r)

        self.qaqc_highlight_outliers()
        self.qaqc_highlight_no_detections_rows()
        self.qaqc_higlight_conditional_formatting()

        # Make sure Validates column is boolean
        # col = get_column_letter(self.qaqc_df.columns.tolist().index(VALIDATES_COL) + 1)
        # for cell in ws[f"{col}:{col}"]:
        #     cell.data_type = "b"

        self.apply_formatting_rules()

        # Bold the headers
        if ws is not None:
            for cell in ws["1:1"]:
                cell.font = Font(color="00000000", bold=True)

    def remove_all_outliers(self, data, master_df):
        """Remove all outlier Ct values in the data by setting them to None. Data are matched together
        based on gene and sample ID.
        """            
        # data[OUTLIER_COL] = None

        if not self.has_qaqc():
            return

        main_outliers_info = self.qaqc_config.get("main_ct_outliers", None)
        cal_outliers_info = self.qaqc_config.get("cal_ct_outliers", None)

        for all_outliers_info, unit_tag, use_unit_col in [(main_outliers_info, "Ct", True), (cal_outliers_info, "Ct_Std", False)]:
            if all_outliers_info is None:
                continue
            
            for outliers_info in all_outliers_info:
                if use_unit_col:
                    ct_values = data[data[self.config.input.unit_col] == unit_tag]
                else:
                    ct_values = data[data[self.config.input.unit_other_col] == unit_tag]
                gene_groups = ct_values.groupby(self.config.input.gene_type_col)
                apply_to_genes = outliers_info.get("genes", [])
                if isinstance(apply_to_genes, str):
                    apply_to_genes = [apply_to_genes]
                if apply_to_genes is not None:
                    apply_to_genes = [g.strip().lower() for g in apply_to_genes]
                rng = outliers_info.get("range", None)
                max_stdev = outliers_info.get("max_stdev", None)
                min_replicates = outliers_info.get("min_replicates", None)
                max_replicates = outliers_info.get("max_replicates", None)

                # We group by gene and sample ID
                for gene_name, gene_group in gene_groups:
                    if len(apply_to_genes) > 0 and gene_name.lower() not in apply_to_genes:
                        continue
                    for idx, sample_id in enumerate(gene_group[self.config.input.sample_id_col].str.lower().unique()):
                        cur_data = gene_group[gene_group[self.config.input.sample_id_col].str.lower() == sample_id]
                        cur_data = cur_data.copy()

                        self.flag_outliers(cur_data, [data, master_df], max_stdev, rng, min_replicates, max_replicates)

                        # orderings = None
                        # if "grouped_values" in outliers_info:
                        #     for grouped_values in outliers_info.grouped_values:
                        #         genes = grouped_values.genes
                        #         if isinstance(genes, str):
                        #             genes = [genes]
                        #         genes = [g.strip().lower() for g in genes]
                        #         if gene_name.lower() in genes:
                        #             orderings = grouped_values.groups
                        #             break

                        # # orderings is an optional 2d array. Each subarray specifies the indices to group values by
                        # # eg. [[0,1,2], [3,4,5]] will group items [0,1,2] and remove outliers from them, then group
                        # # items [3,4,5] and separately remove outliers from them. Groupings are specified
                        # # in outliers.grouped_values in the config file.
                        # if orderings is None:
                        #     self.flag_outliers(cur_data, [data, master_df], max_stdev, rng, min_replicates, max_replicates)
                        # else:
                        #     for ordering in orderings:
                        #         ordering = [o for o in ordering if o < len(cur_data.index)]
                        #         ordered_data = cur_data.sort_values(self.config.input.index_col).iloc[ordering]
                        #         ordered_data = ordered_data.copy()
                        #         self.flag_outliers(ordered_data, [data, cur_data, master_df], max_stdev, rng, min_replicates, max_replicates)

    def flag_outliers(self, data, modify_dfs, max_stdev, rng, min_replicates, max_replicates):
        """Go through the data and mark all outliers with None in the Ct column until the
        standard deviation is <= max_stdev (with at least min_replicates items). The data are
        treated as a single group.

        Parameters
        ----------
        data : pd.DataFrame
            Data to remove outliers from (by setting the Ct value to None).
        modify_dfs: pd.DataFrame | list | tuple | np.ndarray
            If specified, then the matching Ct values in these DataFrames are also set to None, using
            the same index used in data. The indices in each of these dfs should correspond to the indices
            in data (eg. they can be the parent DataFrame that data was taken from).
        max_stdev : float
            Maximum value of the standard deviation. We remove values until the standard
            deviation of the group is <= this.
        min_replicates : int
            Minimum number of replicates allowed. If we reach this then we stop removing outliers.
        max_replicates : int
            Maximum replicates to use for calculating standard deviation to determine outliers. At most the first
            max_replicates numbers in data are used (value beyond that are ignored)
        """
        if isinstance(modify_dfs, pd.DataFrame):
            modify_dfs = [modify_dfs]

        ct = self.config.input.value_col
        max_replicates = min(len(data.index), max_replicates) if max_replicates is not None else len(data.index)
        min_replicates = min_replicates or 0
        
        if rng is not None:
            for idx in data[ct].iloc[:max_replicates].index:
                if (data[ct].iloc[:max_replicates].isna()).sum() <= min_replicates:
                    break
                if not self.is_in_range(data.loc[idx, ct], rng):
                    data.loc[idx, ct] = None
                    for df in modify_dfs:
                        df.loc[idx, OUTLIER_COL] = df.loc[idx, ct]
                        df.loc[idx, ct] = None

        if max_stdev is not None:
            mean = data[ct].iloc[:max_replicates].mean()
            stdev = data[ct].iloc[:max_replicates].std()
            while stdev > max_stdev and (~data[ct].iloc[:max_replicates].isna()).sum() > min_replicates:
                diff = (data.iloc[:max_replicates][~data[ct].iloc[:max_replicates].isna()][ct] - mean).abs()
                argmax = diff.argmax()
                idx = diff.index[argmax]
                val = data.loc[idx, ct]
                data.loc[idx, ct] = None
                if modify_dfs is not None:
                    for df in modify_dfs:
                        df.loc[idx, OUTLIER_COL] = df.loc[idx, ct]
                        df.loc[idx, ct] = None
                mean = data[ct].iloc[:max_replicates].mean()
                stdev = data[ct].iloc[:max_replicates].std()

    def make_cell_link(self, cell_addr, type=1):
        """Get a hyperlink Excel formula to link to the specified cells.

        Parameters
        ----------
        cell_addr : str | list | tuple | np.ndarray
            The cell address to link to. Can be an array.
        type : int
            If 0, then link to the first address in cell_addr, and make
            the visible text in the hyperlink equal to all addresses in cell_addr
            If 1, then link to the first address in cell_addr
            If 2, then link to the second address in cell_addr, and make
            the visible text in the hyperlink equal to cell_addr[1:], to show
            all secondary addresses.

        Returns
        -------
        str
            A =HYPERLINK() Excel formula that can be placed in an Excel cell.
        """
        # If type = 1, then only return a link to the first address in cell_addr
        if isinstance(cell_addr, str):
            cell_addr = [cell_addr]
        
        if len(cell_addr) == 0:
            return None

        use_addr = cell_addr
        use_name = cell_addr

        if type == 0:
            use_addr = cell_addr[0]
            use_name = ", ".join(cell_addr)
        elif type == 1:
            use_addr = cell_addr[0]
            use_name = cell_addr[0]
        elif type == 2:
            if len(cell_addr) < 2:
                return None
            else:
                use_addr = cell_addr[1]
                use_name = ", ".join(cell_addr[1:])

        return f"=HYPERLINK(\"#{use_addr}\", \"{use_name}\")"

    def add_failed_category_qaqc_cell(self, category, failed, success, empty, target_ws, target_coordinates):
        if not self.has_qaqc():
            return
            
        try:
            # Get columns in QAQC sheet for "Category" and "Validates"
            cat_column = get_column_letter(self.get_qaqc_column_index(CATEGORY_COL)+1)
            validates_column = get_column_letter(self.get_qaqc_column_index(VALIDATES_COL)+1)
            qaqc_sheet = self.get_sheet_name()

            failed_priority = self.qaqc_config.failed_categories.get("failed_priority", None)
            success_priority = self.qaqc_config.failed_categories.get("success_priority", None)
            empty_priority = self.qaqc_config.failed_categories.get("empty_priority", None)

            if failed_priority is None:
                failed = ""
            if success_priority is None:
                success = ""
            if empty_priority is None:
                empty = ""

            # Build the formula to return
            format_args = {
                "category" : category,
                "qaqc_sheet" : qaqc_sheet,
                "cat_column" : cat_column,
                "validates_column" : validates_column,
            }
            failed = failed.format(**format_args)
            success = success.format(**format_args)
            empty = empty.format(**format_args)
            format_args.update({
                "failed" : failed,
                "success" : success,
                "empty" : empty,
            })
            formula = QAQC_HAS_FAILED_CATEGORY_FORMULA.format(**format_args)

            # Add the formatting rules to highlight success/empty and errors
            if failed_priority is not None:
                failed_formula = f"{target_coordinates}=\"{failed}\""
                self.append_custom_formatting_rule(target_ws, failed_priority, target_coordinates, failed_formula)
            if success_priority is not None:
                success_formula = f"{target_coordinates}=\"{success}\""
                self.append_custom_formatting_rule(target_ws, success_priority, target_coordinates, success_formula)
            if empty_priority is not None:
                empty_formula = f"{target_coordinates}=\"{empty}\""
                self.append_custom_formatting_rule(target_ws, empty_priority, target_coordinates, empty_formula)
                
            return formula        
        except Exception as e:
            import traceback
            traceback.print_exc()

